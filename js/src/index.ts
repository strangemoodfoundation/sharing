import { ENV, MAINNET, TESTNET, DEVNET } from './constants';
import { pda } from './pda';
import * as splToken from '@solana/spl-token';
import {
  ConfirmOptions,
  Connection,
  Keypair,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction,
} from '@solana/web3.js';
import { BN, Program, Provider, web3 } from '@project-serum/anchor';
import { Sharing } from '../../target/types/sharing';
import { Wallet } from '@project-serum/anchor/dist/cjs/provider';

export default {
  MAINNET,
  DEVNET,
  TESTNET,
};

const borshifyFloat = (a: number) => {
  const pieces = a.toString().split('.');
  const splitAmount = parseInt(pieces[0]);
  const splitDecimal = parseInt(pieces[1]);

  return [splitAmount, splitDecimal];
};

const getAssociatedTokenAddress = async (pubkey: PublicKey) => {
  console.log('getAssociatedTokenAddress: ', pubkey.toString());
  const addy = await splToken.Token.getAssociatedTokenAddress(
    splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
    splToken.TOKEN_PROGRAM_ID,
    splToken.NATIVE_MINT,
    pubkey,
    true
  );

  console.log(addy.toString());
  return addy;
};

const getOrCreateAssociatedTokenAccount = async (
  connection: Connection,
  pubkey: PublicKey
) => {
  const address = await getAssociatedTokenAddress(pubkey);
  const acctInfo = await connection.getAccountInfo(address);

  let itx: TransactionInstruction | null = null;

  if (!acctInfo || !acctInfo.owner) {
    console.log(
      'Account Info does not exist! creating assocaited token account'
    );
    itx = await splToken.Token.createAssociatedTokenAccountInstruction(
      splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
      splToken.TOKEN_PROGRAM_ID,
      splToken.NATIVE_MINT,
      address,
      pubkey,
      pubkey
    );
  } else {
    console.log('acct info exists:', {
      data: acctInfo.data.toString(),
      owner: acctInfo.owner.toString(),
    });
  }

  return {
    address,
    instruction: itx,
  };
};

const getSharingAccounts = async (
  connection: Connection,
  user: PublicKey,
  assetPubkey: PublicKey
) => {
  console.log('getSharingAccounts: ', {
    user: user.toString(),
    asset: assetPubkey.toString(),
  });
  // wrapped SOL account associated with the current user.
  let { address: associatedSolAddress, instruction: createAccountInstruction } =
    await getOrCreateAssociatedTokenAccount(connection, user);

  // The sharing account address is derived from the current user's token acct
  let [sharingPDA, sharingBump] = await pda.sharing(
    associatedSolAddress,
    assetPubkey
  );

  // // The sharing account TOKEN address is related to the sharing acct address
  let associatedSharingSolAddress = await getAssociatedTokenAddress(sharingPDA);

  return {
    associatedSolAddress,
    associatedSharingSolAddress,
    sharingPDA,
    sharingBump,
    createAccountInstruction,
  };
};

/**
 * * We need to set the wrapped token account of the sharing keypair to be the destinationSolAcct for strangemood (or another program)
 * This init fn uses the the current user's address to create the sharing acct, and then uses that address to create a wrapped sol acct.
 *
 * Consequences of this approach: when the destination account changes, a new sharing acct is needed. We are okay with this consequence :P
 * @param program
 * @param user
 * @param config
 */
export const initSharingAccount = async (
  connection: Connection,
  program: Program<Sharing>,
  user: PublicKey,
  assetPubkey: PublicKey,
  config: { splitPercent: number }
) => {
  const tx = new Transaction();
  const {
    associatedSharingSolAddress,
    associatedSolAddress,
    sharingBump,
    sharingPDA,
    createAccountInstruction,
  } = await getSharingAccounts(connection, user, assetPubkey);

  if (createAccountInstruction) tx.add(createAccountInstruction);

  const [splitAmount, splitDecimal] = borshifyFloat(config.splitPercent);

  const initTx = program.instruction.initSharingAccount(
    sharingBump,
    assetPubkey,
    new BN(splitAmount),
    new BN(splitDecimal),
    {
      accounts: {
        user,
        sharingAccount: sharingPDA,
        depositAccount: associatedSolAddress,
        tokenAccountPda: associatedSharingSolAddress, // now autogenerated!
        systemProgram: SystemProgram.programId,

        // for programatically creating PDA:
        associatedTokenProgram: splToken.ASSOCIATED_TOKEN_PROGRAM_ID,
        tokenProgram: splToken.TOKEN_PROGRAM_ID,
        mint: splToken.NATIVE_MINT,
        rent: web3.SYSVAR_RENT_PUBKEY,
      },
    }
  );

  console.log('initTx Configured:', initTx);

  tx.add(initTx);
  return tx;
};

export const updateSharingAccountPercentage = async (
  connection: Connection,
  program: Program<Sharing>,
  user: PublicKey,
  assetPubkey: PublicKey,
  config: { splitPercent: number }
) => {
  const {
    associatedSharingSolAddress,
    associatedSolAddress,
    // sharingBump,
    sharingPDA,
  } = await getSharingAccounts(connection, user, assetPubkey);

  const [splitAmount, splitDecimal] = borshifyFloat(config.splitPercent);

  await program.rpc.updateSharingAccount(
    new BN(splitAmount),
    new BN(splitDecimal),
    {
      accounts: {
        user: user,
        sharingAccount: sharingPDA,
        systemProgram: SystemProgram.programId,
      },
    }
  );
};

export const fetchSharingProgram = async (
  provider: Provider,
  programId = ENV.SHARING_PROGRAM_ID
) => {
  const idl = await Program.fetchIdl<Sharing>(programId, provider);
  if (!idl)
    throw new Error(
      'IDL Not Found: Did you make sure to run `anchor idl anchor idl init --filepath target/idl/sharing.json "[PROGRAM_ID]" --provider.cluster [CLUSETER]`'
    );

  return new Program(idl, programId, provider);
};

export const getSharingProvider = async (
  connection: Connection,
  wallet: Wallet,
  opts?: ConfirmOptions
) => {
  if (!wallet) throw new Error('Wallet Not Connected');

  console.log('here!');

  const provider = new Provider(connection, wallet, opts ?? {});

  console.log('not here?');
  return provider;
};

// TODO: verify we can invoke these with a provider being passed in, or if we need to do what Memo does with passing in a wallet.
